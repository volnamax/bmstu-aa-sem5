\chapter{Исследовательская часть}

В данном разделе будут приведены: технические характеристики устройства, демонстрация работы программы, сравнительный анализ времени выполнения реализуемых алгоритмов и занимаемой памяти.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялись замеры по времени, представлены далее.

\begin{itemize}
	\item Процессор: Ryzen 5 4600H, тактовая частота ЦПУ 3.0 ГГц, максимальная частота процессора 4.0 ГГц~\cite{ryzen}.
	\item Оперативная память: 16 ГБайт.
	\item Операционная система: Windows 10 Pro 64-разрядная система \cite{windows}.
\end{itemize}

При замерах времени ноутбук был включен в сеть электропитания и был нагружен только системными приложениями.

\section{Демонстрация работы программы}

На рисунке~\ref{img:demka} представлено визуальное представление работы разработанного программного обеспечения. В частности, продемонстрирован результат вычисления классического алгоритма умножения матриц.
Входными данными являются матрицы и располагаются в двух разных файлах, которые имеют следующий вид~\ref{img:file}

\includeimage
	{file} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
	{f} % Обтекание (без обтекания)
	{h} % Положение рисунка (см. figure из пакета float)
	{0.5\textwidth} % Ширина рисунка
	{Пример входных данных} % Подпись рисунк
	

\includeimage
	{demka} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
	{f} % Обтекание (без обтекания)
	{h} % Положение рисунка (см. figure из пакета float)
	{0.5\textwidth} % Ширина рисунка
	{Демонстрация работы программы} % Подпись рисунк


\section{Временные характеристики}

Замеры времени работы реализованных алгоритмов для определенного размера квадратных матриц проводились 100 раз, а затем бралось их среднее арифметическое значение. 
Значения для матриц генерировались случайно.

На рисунке~\ref{img:oneToHundred} представлен результат замеров времени классического алгоритма умножения, алгоритма Винограда (с оптимизацией и без нее) для нечетного размера квадратных матриц.

На рисунке~\ref{img:twoToHundred} представлен результат замеров времени классического алгоритма умножения, алгоритма Винограда (с оптимизацией и без нее) и алгоритма Штрассена для матриц, размер которых --- степени 2.

\includeimage
	{oneToHundred} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
	{f} % Обтекание (без обтекания)
	{h} % Положение рисунка (см. figure из пакета float)
	{0.8\textwidth} % Ширина рисунка
	{Результат замеров времени реализуемых алгоритмов на матрицах нечетных размеров} % Подпись рисунк
	
\includeimage
	{twoToHundred} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
	{f} % Обтекание (без обтекания)
	{h} % Положение рисунка (см. figure из пакета float)
	{0.8\textwidth} % Ширина рисунка
	{Результат замеров времени реализуемых алгоритмов на матрицах размеры которых --- степени 2} % Подпись рисунк
	
\clearpage	

\section{Характеристики по памяти}

Введем следующие обозначения:

\begin{itemize}
	\item $\text{size}(v)$~--- функция, вычисляющая размер входного параметра $v$ в байтах;
	\item $int$~--- целочисленный тип данных.
\end{itemize}

\textbf{Классический алгоритм}

Теоретическая оценка объема используемой памяти для реализации классического алгоритма умножения целочисленных матриц, размером $n \times n$:
\begin{equation}
	\label{eqn:mem-classic}
	\begin{aligned}
		M_{Classic} = 3 \cdot \text{size}(int) + 3 \cdot \text{size}(int) + n \cdot n \cdot \text{size}(int) = \\
		= \text{size}(int) \cdot (6 + n^2),
	\end{aligned}    
\end{equation}
где $3 \cdot \text{size}(int)$~--- размер переменных для хранения размеров матриц,
\\ $3 \cdot \text{size}(int)$~--- размер переменных цикла,
\\ $n \cdot n \cdot \text{size}(int)$~--- размер результирующей матрицы.

\textbf{Алгоритм Винограда}

Теоретическая оценка объема используемой памяти для реализации алгоритма Винограда (матрицы целочисленные и размером $n \times n$):

\begin{equation}
	M_{Winograd} = M_{row} + M_{col} + M_{res} + M_{mul} + M_{odd},
\end{equation}
где $M_{row}, M_{col}$~--- размер вспомогательных массивов,
\\ $M_{res}$~--- размер результирующей матрицы,
\\ $M_{mul}$~--- размер памяти, используемой при умножении матриц,
\\ $M_{odd}$~--- размер памяти, используемой при обработке условия о нечетности размеров матриц.

Размер результирующей матрицы рассчитывается по формуле (\ref{eqn:mem-result-mat})
\begin{equation}
	\label{eqn:mem-result-mat}
	M_{res} = n \cdot n \cdot \text{size}(int).
\end{equation}

Количество памяти, затрачиваемой на хранение массивов $row$ и $col$ равно
\begin{equation}
	M_{row} = M_{col} = n \cdot \text{size}(int).
\end{equation}

При умножении размер используемой памяти равен
\begin{equation}
	M_{mul} = 3 \cdot \text{size}(int),
\end{equation}
где $3 \cdot \text{size}(int)$~--- переменные цикла.


Количество памяти, затрачиваемой на обработку случая, когда матрица имеет нечетный размер, равно
\begin{equation}
	\label{eqn:mem-winograd-odd}
	M_{odd} = 
	\begin{cases}
		0, & \text{четная}\\
		2 \cdot \text{size}(int), & \text{нечетная}
	\end{cases}
\end{equation}

\textbf{Оптимизированный алгоритм Винограда}

Теоретическая оценка объема используемой памяти для реализации оптимизированной версией алгоритма Винограда (матрицы целочисленные и размером $n \times n$):

\begin{equation}
	M_{WinogradOpt} = M_{row} + M_{col} + M_{res} + M_{mul} + M_{odd} + \text{size}(int),
\end{equation}
где $M_{row}, M_{col}$~--- размер вспомогательных массивов,
\\ $M_{res}$~--- размер результирующей матрицы,
\\ $M_{mul}$~--- размер памяти, используемой при умножении матриц,
\\ $M_{odd}$~--- размер памяти, используемой при обработке условия о нечетности размеров матриц,
\\ $\text{size}(int)$~--- размер переменной, используемой для кеширования.

Размер памяти, необходимой для обработки массивов $row$ и $col$, равен
\begin{equation}
	M_{row} = M_{col} = n \cdot \text{size}(int) + \text{size}(int),
\end{equation}
где $\text{size}(int)$~--- размер переменной, используемой для кеширования.

Количество памяти, затрачиваемой на умножение, равно
\begin{equation}
	M_{mul} = 3 \cdot \text{size}(int) + \text{size}(int),
\end{equation}
где $\text{size}(int)$~--- размер переменной, используемой для кеширования.

$M_{res}$ и $M_{odd}$ рассчитываются согласно соотношениям (\ref{eqn:mem-result-mat}) и (\ref{eqn:mem-winograd-odd}) соотвественно.

\textbf{Алгоритм Штрассена}

Теоретическая оценка объема используемой памяти, затрачиваемой при каждом рекурсивном вызове для реализации алгоритма Штрассена (матрицы целочисленные и размером $n \times n$):

\begin{equation}
	\begin{gathered}
		M_{StrassenCall} = (4 \cdot \frac{n}{2} \cdot \frac{n}{2} + 4 \cdot \frac{n}{2} \cdot \frac{n}{2} + 11 \cdot \frac{n}{2} \cdot \frac{n}{2} + n \cdot n) \cdot \text{size}(int) + \\
		+ 2 \cdot \text{size}(int),
	\end{gathered}
\end{equation}
где $2 \cdot \text{size}(int)$~--- размер переменных, используемых для кеширования,
\\ $4 \cdot \frac{n}{2} \cdot \frac{n}{2} \cdot \text{size}(int)$~--- размер матриц, полученных в результате разбиения исходных на 4 части,
\\ $11 \cdot \frac{n}{2} \cdot \frac{n}{2} \cdot \text{size}(int)$~--- размер промежуточных матриц,
\\ $n \cdot n \cdot \text{size}(int)$~--- размер результирующей матрицы.

\section{Вывод}
\addcontentsline{toc}{section}{Вывод}

В результате исследования реализуемых алгоритмов по времени выполнения можно сделать следующие выводы:
\begin{enumerate}
	\item реализация оптимизированного алгоритма Винограда оказалась наиболее эффективной по времени, независимо от размерности входных матриц (см. рисунки~\ref{img:oneToHundred}~--~\ref{img:twoToHundred}).
	
	\item реализация алгоритма Штрассена по итогам исследования оказалась наименее эффективной по времени (см. рисунок~\ref{img:twoToHundred}).
	Полученный результат объясняется малыми размерами матриц. Однако из-за того, что алгоритм рекурсивный, достижение необходимых размеров матриц, при которых реализация алгоритма Штрассена показала бы преимущество, оказывается невозможным.
	
	\item на матрицах нечетного размера оптимизированная и неоптимизированная реализация алгоритмов Винограда работают медленнее, чем на матрицах четного размера (см. рисунки~\ref{img:oneToHundred}~--~\ref{img:twoToHundred}). Это происходит из-за дополнительных вычислений для крайних строк и столбцов в результирующей матрице.
\end{enumerate}

В результате теоретической оценки объема используемой памяти для реализаций 
алгоритмов можно сделать следующие выводы:
\begin{enumerate}
	\item реализация классического алгоритма умножения матриц требует наименьших расходов по памяти.
	\item реализация алгоритма Штрассена, напротив, является самой требовательной по памяти за счет использования вспомогательных подматриц для выполнения расчетов и рекурсивных вызовов.
	\item оптимизированная реализация алгоритма Винограда более ресурсозатратна по сравнению с неоптимизированной, поскольку включает в себя использование дополнительных переменных для хранения промежуточных расчетов.
\end{enumerate}